<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Linevision: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Linevision
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Unidade Curricular DA</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a089f7fc73ea9976295d387846ad36c69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a089f7fc73ea9976295d387846ad36c69">findVertex</a> (const int &amp;id) const</td></tr>
<tr class="separator:a089f7fc73ea9976295d387846ad36c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8763fcfd7222571a81ee9de58e51d3fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8763fcfd7222571a81ee9de58e51d3fd">addVertex</a> (const int &amp;id, <a class="el" href="class_station.html">Station</a> station)</td></tr>
<tr class="separator:a8763fcfd7222571a81ee9de58e51d3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4211bf1782cc0f3c60ce969f5bf349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9c4211bf1782cc0f3c60ce969f5bf349">addEdge</a> (const int &amp;source, const int &amp;dest, int capacity, const std::string &amp;service) const</td></tr>
<tr class="separator:a9c4211bf1782cc0f3c60ce969f5bf349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619ac583094079134074658e29463c0e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a619ac583094079134074658e29463c0e">getVertexSet</a> () const</td></tr>
<tr class="separator:a619ac583094079134074658e29463c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e4fc836ea15984157cfcffaaa8371d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a95e4fc836ea15984157cfcffaaa8371d">minCost</a> (int source, int target)</td></tr>
<tr class="separator:a95e4fc836ea15984157cfcffaaa8371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7902f8f8a5ef7cc0319afcc95af0b1a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7902f8f8a5ef7cc0319afcc95af0b1a4">maxFlow</a> (int source, int target)</td></tr>
<tr class="memdesc:a7902f8f8a5ef7cc0319afcc95af0b1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the maximum flow from the source vertex to the target vertex using the Edmonds-Karp algorithm.  <a href="class_graph.html#a7902f8f8a5ef7cc0319afcc95af0b1a4">More...</a><br /></td></tr>
<tr class="separator:a7902f8f8a5ef7cc0319afcc95af0b1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e9ec030f47ba1ae53303606bdcebca"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a12e9ec030f47ba1ae53303606bdcebca">maxConnectedDistrict</a> (const std::string &amp;district)</td></tr>
<tr class="separator:a12e9ec030f47ba1ae53303606bdcebca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cadedd8ec19cf519d6a651ae3d8f19"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a08cadedd8ec19cf519d6a651ae3d8f19">maxConnectedMunicipality</a> (const std::string &amp;municipality)</td></tr>
<tr class="separator:a08cadedd8ec19cf519d6a651ae3d8f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ada20033a1f3809827d5251bfeb8a84d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ada20033a1f3809827d5251bfeb8a84d7">findAugmentingPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *src, <a class="el" href="class_vertex.html">Vertex</a> *dest)</td></tr>
<tr class="memdesc:ada20033a1f3809827d5251bfeb8a84d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the shortest augmenting path from the source to the target using a BFS.  <a href="class_graph.html#ada20033a1f3809827d5251bfeb8a84d7">More...</a><br /></td></tr>
<tr class="separator:ada20033a1f3809827d5251bfeb8a84d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ee1efb1c4fef61b36d7ee5e52b418b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab4ee1efb1c4fef61b36d7ee5e52b418b">findMinCostAugmentingPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *src, <a class="el" href="class_vertex.html">Vertex</a> *dest)</td></tr>
<tr class="memdesc:ab4ee1efb1c4fef61b36d7ee5e52b418b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum cost augmenting path from the source vertex to the destination vertex.  <a href="class_graph.html#ab4ee1efb1c4fef61b36d7ee5e52b418b">More...</a><br /></td></tr>
<tr class="separator:ab4ee1efb1c4fef61b36d7ee5e52b418b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cd54a73032d80ac05c4b7c495b5acd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a60cd54a73032d80ac05c4b7c495b5acd">dfsConnectedDistrict</a> (<a class="el" href="class_vertex.html">Vertex</a> *v, std::list&lt; int &gt; &amp;comp, const std::string &amp;district)</td></tr>
<tr class="separator:a60cd54a73032d80ac05c4b7c495b5acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5156488afc53b4e047f6a4b7c082b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a5c5156488afc53b4e047f6a4b7c082b8">dfsConnectedMunicipality</a> (<a class="el" href="class_vertex.html">Vertex</a> *v, std::list&lt; int &gt; &amp;comp, const std::string &amp;municipality)</td></tr>
<tr class="separator:a5c5156488afc53b4e047f6a4b7c082b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a239d63949207e09f989868fb999ea8ca"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a239d63949207e09f989868fb999ea8ca">findMinResidualAlongPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *src, <a class="el" href="class_vertex.html">Vertex</a> *dest)</td></tr>
<tr class="memdesc:a239d63949207e09f989868fb999ea8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the minimum residual capacity along the chosen augmenting path from the source to the target.  <a href="class_graph.html#a239d63949207e09f989868fb999ea8ca">More...</a><br /></td></tr>
<tr class="separator:a239d63949207e09f989868fb999ea8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb278aa71f7d4b95ebf66dfa7bc15f4f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#adb278aa71f7d4b95ebf66dfa7bc15f4f">augmentFlowAlongPath</a> (<a class="el" href="class_vertex.html">Vertex</a> *src, <a class="el" href="class_vertex.html">Vertex</a> *dest, int flow)</td></tr>
<tr class="memdesc:adb278aa71f7d4b95ebf66dfa7bc15f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augments the flow along the chosen augmenting path from the source to the target.  <a href="class_graph.html#adb278aa71f7d4b95ebf66dfa7bc15f4f">More...</a><br /></td></tr>
<tr class="separator:adb278aa71f7d4b95ebf66dfa7bc15f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa9b0a6d8ad43c5eabaca5a7140bcc8b6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa9b0a6d8ad43c5eabaca5a7140bcc8b6">vertexSet</a></td></tr>
<tr class="separator:aa9b0a6d8ad43c5eabaca5a7140bcc8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9c4211bf1782cc0f3c60ce969f5bf349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4211bf1782cc0f3c60ce969f5bf349">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>service</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8763fcfd7222571a81ee9de58e51d3fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8763fcfd7222571a81ee9de58e51d3fd">&#9670;&nbsp;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addVertex </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_station.html">Station</a>&#160;</td>
          <td class="paramname"><em>station</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb278aa71f7d4b95ebf66dfa7bc15f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb278aa71f7d4b95ebf66dfa7bc15f4f">&#9670;&nbsp;</a></span>augmentFlowAlongPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::augmentFlowAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Augments the flow along the chosen augmenting path from the source to the target. </p>
<p>This function updates the flow along the chosen augmenting path from the source vertex to the target vertex in the graph by adding or subtracting the flow amount from the residual capacity of each edge along the path.<br  />
<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A pointer to the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>A pointer to the target vertex. </td></tr>
    <tr><td class="paramname">flow</td><td>The amount of flow to augment along the path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V + E), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a60cd54a73032d80ac05c4b7c495b5acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60cd54a73032d80ac05c4b7c495b5acd">&#9670;&nbsp;</a></span>dfsConnectedDistrict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dfsConnectedDistrict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>district</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the path of the stations of a specific district.<br  />
<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>wanted vertex to see size of connected component </td></tr>
    <tr><td class="paramname">comp</td><td>contains all connected vertexes </td></tr>
    <tr><td class="paramname">district</td><td>wanted district</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V + E), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a5c5156488afc53b4e047f6a4b7c082b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5156488afc53b4e047f6a4b7c082b8">&#9670;&nbsp;</a></span>dfsConnectedMunicipality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dfsConnectedMunicipality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>municipality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the path of the stations of a specific municipality.<br  />
<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>wanted vertex to see size of connected component </td></tr>
    <tr><td class="paramname">comp</td><td>contains all connected vertexes </td></tr>
    <tr><td class="paramname">municipality</td><td>wanted municipality</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V + E), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="ada20033a1f3809827d5251bfeb8a84d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada20033a1f3809827d5251bfeb8a84d7">&#9670;&nbsp;</a></span>findAugmentingPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::findAugmentingPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the shortest augmenting path from the source to the target using a BFS. </p>
<p>This function finds the shortest augmenting path from the source vertex to the target vertex in the graph using a breadth-first search algorithm.<br  />
<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A pointer to the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>A pointer to the target vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a path from the source to the target was found, false otherwise.</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V + E), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="ab4ee1efb1c4fef61b36d7ee5e52b418b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ee1efb1c4fef61b36d7ee5e52b418b">&#9670;&nbsp;</a></span>findMinCostAugmentingPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::findMinCostAugmentingPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the minimum cost augmenting path from the source vertex to the destination vertex. </p>
<p>This function uses Dijkstra's algorithm with a priority queue to find the minimum cost augmenting path from the source vertex to the destination vertex in the graph. The function updates the path information for each visited vertex and returns a boolean indicating whether a path was found or not.<br  />
<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A pointer to the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>A pointer to the destination vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a minimum cost augmenting path was found, false otherwise.</dd></dl>
<dl class="section user"><dt>Time Complexity</dt><dd>O((V + E) * log(V)), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a239d63949207e09f989868fb999ea8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239d63949207e09f989868fb999ea8ca">&#9670;&nbsp;</a></span>findMinResidualAlongPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::findMinResidualAlongPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the minimum residual capacity along the chosen augmenting path from the source to the target. </p>
<p>This function finds the minimum residual capacity along the chosen augmenting path from the source vertex to the target vertex in the graph, by examining each edge along the path and returning the smallest residual capacity.<br  />
<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A pointer to the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>A pointer to the target vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bottleneck capacity of the chosen augmenting path from the source to the target.</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V + E), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a089f7fc73ea9976295d387846ad36c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089f7fc73ea9976295d387846ad36c69">&#9670;&nbsp;</a></span>findVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vertex.html">Vertex</a> * Graph::findVertex </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a619ac583094079134074658e29463c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619ac583094079134074658e29463c0e">&#9670;&nbsp;</a></span>getVertexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_vertex.html">Vertex</a> * &gt; Graph::getVertexSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12e9ec030f47ba1ae53303606bdcebca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e9ec030f47ba1ae53303606bdcebca">&#9670;&nbsp;</a></span>maxConnectedDistrict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Graph::maxConnectedDistrict </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>district</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calculates the largest connected component of a district using a depth-first search algorithm.<br  />
<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">district</td><td>wanted district</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the largest connected component</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V + E), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a08cadedd8ec19cf519d6a651ae3d8f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cadedd8ec19cf519d6a651ae3d8f19">&#9670;&nbsp;</a></span>maxConnectedMunicipality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Graph::maxConnectedMunicipality </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>municipality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calculates the largest connected component of a municipality using a depth-first search algorithm.<br  />
<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">municipality</td><td>wanted municipality</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of the largest connected component</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V + E), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a7902f8f8a5ef7cc0319afcc95af0b1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7902f8f8a5ef7cc0319afcc95af0b1a4">&#9670;&nbsp;</a></span>maxFlow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::maxFlow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the maximum flow from the source vertex to the target vertex using the Edmonds-Karp algorithm. </p>
<p>This function implements the Edmonds-Karp algorithm to find the maximum flow from the source vertex to the target vertex in the graph. The algorithm works by repeatedly finding the shortest augmenting path from the source to the target using BFS, and then augmenting the flow along that path until no more augmenting paths exist. <br  />
<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The identifier of the source vertex. </td></tr>
    <tr><td class="paramname">target</td><td>The identifier of the target vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum flow from the source vertex to the target vertex.</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V * E²), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a95e4fc836ea15984157cfcffaaa8371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e4fc836ea15984157cfcffaaa8371d">&#9670;&nbsp;</a></span>minCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::minCost </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function calculates the minimum cost maximum flow from the source vertex to the destination vertex using the successive shortest path algorithm.<br  />
<br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The identifier of the source vertex. </td></tr>
    <tr><td class="paramname">target</td><td>The identifier of the target vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum cost of the flow from the source to the target, or 0 if there is no feasible flow.</dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V * E² * log(V)), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa9b0a6d8ad43c5eabaca5a7140bcc8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b0a6d8ad43c5eabaca5a7140bcc8b6">&#9670;&nbsp;</a></span>vertexSet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_vertex.html">Vertex</a> *&gt; Graph::vertexSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/luisdu/CLionProjects/feup-da-proj1/code/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>/home/luisdu/CLionProjects/feup-da-proj1/code/<a class="el" href="_graph_8cpp.html">Graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
